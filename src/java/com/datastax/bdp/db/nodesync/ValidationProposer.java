/*
 * Copyright DataStax, Inc.
 *
 * Please see the included license file for details.
 */
package com.datastax.bdp.db.nodesync;

import java.util.function.Consumer;

import org.apache.cassandra.schema.TableMetadata;

/**
 * A {@link ValidationProposer} is an object that generates segment validation proposal ({@link ValidationProposal}).
 * <p>
 * A proposer may be finite, generating a number of proposals before being done, or infinite, generating proposals as
 * long as asked to. The generation of a validation proposal is done by calling the {@link #supplyNextProposal(Consumer)},
 * passing a consumer of that generated proposal.
 */
// TODO(sylvain): it might be that, once merged with TPC, making this be a Flow<ValidationProposal> could be a slightly
// cleaner approach conceptually (mostly because it'd reuse an existing concept). Assuming CsFlow request() isn't
// blocking, which I believe it's not. Not really worth bothering short term though.
interface ValidationProposer
{
    /**
     * Called before the proposer is used to perform any initialization necessary for this proposer.
     * <p>
     * This exists because we want to keep the ctor of {@link ValidationProposer} sub-classes cheap (due to how we use the
     * equals behavior in {@link ValidationScheduler}), and so this allow to offload any initial "costly" work to this method.
     */
    void init();

    /**
     * Called by users of the proposer so the proposer supplies (potentially asynchronously) his next proposal.
     * <p>
     * Importantly, callers should not assume that the new proposal is supplied synchronously by this method (this is
     * why we pass a consumer of the proposal rather than return the proposal directly): the proposer is allowed to delay
     * his next proposal (either because it don't want any proposal to be executed right now, or because computing the
     * next proposal is costly and is better done asynchronously). Callers can however expect that calling this method
     * is non-blocking, and implementors should ensure that it is.
     * <p>
     * Callers should however ensure that this method isn't called again until the {@code proposalConsumer} has been
     * called by this method (even if it's done asynchronously), which implies that it isn't called concurrently in
     * particular.
     *
     * @param proposalConsumer the consumer to which the next proposal generated by proposer should be passed (again, the
     *                         proposal may be supplied to this consumer asynchronously).
     * @return {@code false} if the proposer is done (has no more proposal ever, in which case {@code proposalConsumer}
     * should not be called), {@code true} otherwise.
     */
    boolean supplyNextProposal(Consumer<ValidationProposal> proposalConsumer);

    /**
     * Returns whether is the proposer is done, meaning that it has no more proposal to provide and it could be disposed
     * of. It's allowed for proposers to never be done (to supply proposal indefinitely), in which case this method will
     * always return {@code false}. Note that returning {@code true} doesn't mean that all the proposal generate by this
     * proposer have been _executed_, only that any following call to {@link #supplyNextProposal} would do nothing and
     * return {@code false}.
     */
    boolean isDone();

    /**
     * The service for which the proposer has been created.
     */
    NodeSyncService service();

    /**
     * Called when a table has been altered to know how the proposer is affected by that change.
     *
     * @param table the table that has been altered (note: currently, SchemaChangeListener only tell us a table has been
     *              altered but don't really tell us how. We should change that someday so it at least give us the
     *              metadata before and after the change so we can easily figure out what changed, but it'll have to do
     *              for now).
     * @return a proposer that correspond to how this proposer is affected by the new state of the provided {@code table}.
     * More precisely, this should be {@code null} if the proposer is invalidated (should be removed) by the table update,
     * {@code this} if the proposer is unaffected, or a new proposer object that should replace this one if this is more
     * appropriate.
     */
    ValidationProposer onTableUpdate(TableMetadata table);

    /**
     * Called when a table has been dropped to know how the proposer is affected.
     *
     * @param keyspace the name of the keyspace of the table having been dropped.
     * @param table the name of the table that has been dropped..
     * @return a proposer that correspond to how this proposer is affected by the drop. More precisely, this should be
     * {@code null} if the proposer is invalidated (should be removed) by the table drop, {@code this} if the proposer is
     * unaffected, or a new proposer object that should replace this one if this is more appropriate.
     */
    ValidationProposer onTableRemoval(String keyspace, String table);

    /**
     * Cancel a proposer, forcing it to stop emitting new proposals even if it was not naturally finished.
     * <p>
     * This method <b>must</b> be idempotent: cancelling an already finished or already cancelled proposer should be
     * a no-op and should not, in particular, throw.
     *
     * @return {@code true} if the proposer is cancelled following the call to this method, {@code false} if the
     * proposer had already naturally finished prior to this call.
     */
    boolean cancel();

    /**
     * Whether the proposer has been cancelled before natural completion (through {@link #cancel()}).
     */
    boolean isCancelled();
}
